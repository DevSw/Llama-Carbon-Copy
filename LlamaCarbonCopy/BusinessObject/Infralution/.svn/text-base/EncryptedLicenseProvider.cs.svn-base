//
//      FILE:   EncryptedLicenseProvider.cs
//
//    AUTHOR:   Grant Frisken
//
// COPYRIGHT:   Copyright 2005 
//              Infralution
//              6 Bruce St 
//              Mitcham Australia
//
using System;
using System.ComponentModel;
using System.ComponentModel.Design;
using System.Security.Cryptography;
using System.Diagnostics;
using System.Text;
using System.IO;
using System.Xml;
using System.Globalization;
using System.Reflection;
using System.Collections;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Security;
namespace Infralution.Licensing
{
    /// <summary>
    /// Defines a .NET LicenseProvider that uses encrypted licenses generated by the 
    /// Infralution Licensing System.
    /// </summary>
    /// <remarks>
    /// <p>The Infralution Licensing System provides a secure way of licensing .NET controls,
    /// components and applications.   Licenses are protected using public key encryption to
    /// minimize possibility of cracking.</p>
    /// <p>Components or controls use the <see cref="LicenseProviderAttribute"/> to specify
    /// this class as the LicenseProvider </p>
    /// </remarks>
    /// <example>
    /// This example demonstrates the typical usage of the EncryptedLicenseProvider to license an
    /// application.  The application creates an instance of the EncryptedLicenseProvider and uses
    /// the <see cref="GetLicense(string, string)"/> method to check for an installed license.  If there 
    /// is no valid installed license the generic <see cref="LicenseInstallForm"/> is used to prompt the 
    /// user to install a license.  If the user does not install a license then the user is allowed to
    /// continue but a nag screen is displayed.
    /// <code lang="C#" escaped="true" >
    /// #using Infralution.Licensing;
    /// public class MyForm : Form
    /// {
    ///    const string LICENSE_PARAMETERS = 
    ///       @"<LicenseParameters>
    ///            <RSAKeyValue>
    ///               <Modulus>z7ijwu7osE4HcGZH7+PhOYw3WuZp/+1szNEjrEo61WVO2sklsdVJpjShXPzUDjlDDvnIFZo4d0l8IFswCYleRS+5PVOkqH0OnAHOSIvoHMNxRyKi9klj7ZD55sKfDJu17MUsjLFLc741B8EvQ3dXPLQoTc+TF5mKOm6o8BnrSuU=</Modulus>
    ///               <Exponent>AQAB</Exponent>
    ///            </RSAKeyValue>
    ///            <DesignSignature>NqPti5+oayvPPlaETb5gNi9u32sze0o9AhlVEtWm3rfo3gGV/jKXDqQBd9Icy9xgfrEOVKvCyrhnCUEowQDOBPaVMiDqdm9UBRM/KAQt4kUAb2bhl8W47R09bikvahfJWfP+zyic3oin61B1jvuI2CSYjiRi4a5Qz2hudDP5MxM=</DesignSignature>
    ///            <RuntimeSignature>lL2tfh7eUgkZS+I0/yoRowAP7p++zXma4JgO/Npf0QXnbBy3pKw+B5U9jtfwydKleM22Wgk/KBG5uyYXWaJeG/Pe6I29uLD1s5uo+Y9EzVaXDdi9HMQwIIvrv7dcgZlPPkzmkSm1X3uqfHl9R4+NfP9noDBKiQBVSWkem/iH87E=</RuntimeSignature>
    ///            <KeyStrength>7</KeyStrength>
    ///         </LicenseParameters>";
    ///
    ///     const string LICENSE_FILE = "MyApp.lic";
    ///     
    ///     public MyForm()
    ///     {
    ///         InitializeComponent();
    ///         EncryptedLicenseProvider provider = new EncryptedLicenseProvider();
    ///         EncryptedLicense license = provider.GetLicense(LICENSE_PARAMETERS, LICENSE _FILE);
    ///         if (license == null)
    ///         {
    ///             LicenseInstallForm form = new LicenseInstallForm();
    ///             license = form.ShowDialog("MyControl", "www.mycompany.com", LICENSE _FILE); 
    ///             if (license == null)
    ///             {
    ///                  MessageBox.Show("Running in Evaluation Mode", "Unlicensed Application");
    ///             }
    ///         }
    ///     }
    /// } 
    /// </code>
    /// <code lang ="Visual Basic">
    /// Imports Infralution.Licensing
    /// Public Class MyForm
    ///    Inherits System.Windows.Forms.Form
    ///
    ///    Const LICENSE_PARAMETERS As String = _
    ///        "&lt;LicenseParameters&gt;" &amp; _
    ///        "       &lt;RSAKeyValue&gt;" &amp; _
    ///        "       &lt;Modulus&gt;rzRJ6dZ4ZTJ8/EzFtq2XIaik7QBSc24b8i8KJrPaxXGiCMDFcj8JtEFePa1SYX1W3cQoiwvCAF/MYmkXto74WdApYzILel+bOHSaUXTImrxpPtykNhPD7fF3PEXxrLRrTjUWQyEX5+XSaNPstmbDJw/Zg83mraCfmGeLcsiEypM=&lt;/Modulus&gt;" &amp; _
    ///        "       &lt;Exponent&gt;AQAB&lt;/Exponent&gt;" &amp; _
    ///        "       &lt;/RSAKeyValue&gt;" &amp; _
    ///        "       &lt;DesignSignature&gt;GJYsK2rQE7uj539+QCyJ3Z2GyrNEZQNxruxOQR6P2jo+Ze3Ev5Kgbf3N33RaLf7oEUsZNF4Gv7w5UFgYcdHzCphqznt4vcR++u9tb0sC5m6hf26538GXhkNodyVR9FDcv1AX4+PaM/kY+Z8mrMMmC148lYPpCHypXvgjOmDd9oQ=&lt;/DesignSignature&gt;" &amp; _
    ///        "       &lt;RuntimeSignature&gt;coZIUnOTaRZCIa67HBMM6/xbkQNYS+l4ROeLmzn7SqRamBwP7cbfOEAsxlFV2roKlY6oz1B91/PYcTVPLfWahwjHaiAaLjKAosXK41yZOozu0vRWpv4H9ERiEli0pYX0M8fMBIkvSDT6n9X9T/6U4ujyefv8b4IxbYsB3zsjjx0=&lt;/RuntimeSignature&gt;" &amp; _
    ///        "&lt;/LicenseParameters&gt;"
    ///
    ///    Const LICENSE_FILE as String = "MyApp.lic"
    ///    
    ///    Public Sub New()
    ///         MyBase.New()
    ///         InitializeComponent()
    ///         Dim sProvider as new EncryptedLicenseProvider()
    ///         Dim sLicense as EncryptedLicense = sProvider.GetLicense(LICENSE_PARAMETERS, LICENSE_FILE)
    ///         If sLicense is Nothing Then
    ///             Dim myForm As New LicenseInstallForm
    ///             sLicense = myForm.ShowDialog("MyControl", "www.mycompany.com", LICENSE_FILE)
    ///             If sLicense is Nothing then
    ///                  MessageBox.Show("Running in Evaluation Mode", "Unlicensed Application")
    ///             End If
    ///         End If
    ///    End Sub
    /// End Class   
    /// </code>
    /// </example>
    /// <example>
    /// This example demonstrates the typical usage of the EncryptedLicenseProvider to license a component or
    /// control.  The component/control must first initialize the EncryptedLicenseProvider with the public 
    /// key encryption parameters required to validate the license using <see cref="SetParameters"/>.  
    /// It can then use the .NET license manager to obtain a license for the current context 
    /// (runtime or design).  If there is not a valid license the component designer can  
    /// choose the appropriate course of action based on the context.  In this case the code uses the generic
    /// <see cref="LicenseInstallForm"/> to prompt the user to install a license - but allows use of 
    /// the component without a license for evaluation purposes. Applications created using the unlicensed evaluation 
    /// component will display a nag MessageBox.
    /// <code lang="C#" escaped="true" >
    /// #using Infralution.Licensing;
    /// #using System.ComponentModel;
    /// [LicenseProvider(typeof(Infralution.Licensing.EncryptedLicenseProvider))]
    /// public class MyControl : Control
    /// {
    ///    const string LICENSE_PARAMETERS = 
    ///       @"<LicenseParameters>
    ///            <RSAKeyValue>
    ///               <Modulus>z7ijwu7osE4HcGZH7+PhOYw3WuZp/+1szNEjrEo61WVO2sklsdVJpjShXPzUDjlDDvnIFZo4d0l8IFswCYleRS+5PVOkqH0OnAHOSIvoHMNxRyKi9klj7ZD55sKfDJu17MUsjLFLc741B8EvQ3dXPLQoTc+TF5mKOm6o8BnrSuU=</Modulus>
    ///               <Exponent>AQAB</Exponent>
    ///            </RSAKeyValue>
    ///            <DesignSignature>NqPti5+oayvPPlaETb5gNi9u32sze0o9AhlVEtWm3rfo3gGV/jKXDqQBd9Icy9xgfrEOVKvCyrhnCUEowQDOBPaVMiDqdm9UBRM/KAQt4kUAb2bhl8W47R09bikvahfJWfP+zyic3oin61B1jvuI2CSYjiRi4a5Qz2hudDP5MxM=</DesignSignature>
    ///            <RuntimeSignature>lL2tfh7eUgkZS+I0/yoRowAP7p++zXma4JgO/Npf0QXnbBy3pKw+B5U9jtfwydKleM22Wgk/KBG5uyYXWaJeG/Pe6I29uLD1s5uo+Y9EzVaXDdi9HMQwIIvrv7dcgZlPPkzmkSm1X3uqfHl9R4+NfP9noDBKiQBVSWkem/iH87E=</RuntimeSignature>
    ///            <KeyStrength>7</KeyStrength>
    ///         </LicenseParameters>";
    ///
    ///     public MyControl()
    ///     {
    ///         InitializeComponent();
    ///         EncryptedLicenseProvider.SetParameters(LICENSE_PARAMETERS);
    ///         License license;
    ///         if (!LicenseManager.IsValid(typeof(MyControl), this, out license))
    ///         {
    ///             if (LicenseManager.CurrentContext.UsageMode == LicenseUsageMode.Runtime)
    ///             {
    ///                 MessageBox.Show("This application was created using an unlicensed version of MyControl", 
    ///                                 "Unlicensed Application");
    ///             }
    ///             else
    ///             {
    ///                 LicenseInstallForm form = new LicenseInstallForm();
    ///                 form.ShowDialog("MyControl", "www.mycompany.com", typeof(MyControl)); 
    ///             }
    ///         }
    ///     }
    /// } 
    /// </code>
    /// <code lang ="Visual Basic">
    /// Imports System.ComponentModel
    /// Imports Infralution.Licensing
    /// &lt;LicenseProvider(GetType(Infralution.Licensing.EncryptedLicenseProvider))&gt; _
    /// Public Class MyControl
    ///    Inherits System.Windows.Forms.UserControl
    ///
    ///    Const LICENSE_PARAMETERS As String = _
    ///        "&lt;LicenseParameters&gt;" &amp; _
    ///        "       &lt;RSAKeyValue&gt;" &amp; _
    ///        "       &lt;Modulus&gt;rzRJ6dZ4ZTJ8/EzFtq2XIaik7QBSc24b8i8KJrPaxXGiCMDFcj8JtEFePa1SYX1W3cQoiwvCAF/MYmkXto74WdApYzILel+bOHSaUXTImrxpPtykNhPD7fF3PEXxrLRrTjUWQyEX5+XSaNPstmbDJw/Zg83mraCfmGeLcsiEypM=&lt;/Modulus&gt;" &amp; _
    ///        "       &lt;Exponent&gt;AQAB&lt;/Exponent&gt;" &amp; _
    ///        "       &lt;/RSAKeyValue&gt;" &amp; _
    ///        "       &lt;DesignSignature&gt;GJYsK2rQE7uj539+QCyJ3Z2GyrNEZQNxruxOQR6P2jo+Ze3Ev5Kgbf3N33RaLf7oEUsZNF4Gv7w5UFgYcdHzCphqznt4vcR++u9tb0sC5m6hf26538GXhkNodyVR9FDcv1AX4+PaM/kY+Z8mrMMmC148lYPpCHypXvgjOmDd9oQ=&lt;/DesignSignature&gt;" &amp; _
    ///        "       &lt;RuntimeSignature&gt;coZIUnOTaRZCIa67HBMM6/xbkQNYS+l4ROeLmzn7SqRamBwP7cbfOEAsxlFV2roKlY6oz1B91/PYcTVPLfWahwjHaiAaLjKAosXK41yZOozu0vRWpv4H9ERiEli0pYX0M8fMBIkvSDT6n9X9T/6U4ujyefv8b4IxbYsB3zsjjx0=&lt;/RuntimeSignature&gt;" &amp; _
    ///        "&lt;/LicenseParameters&gt;"
    ///
    ///    Public Sub New()
    ///         MyBase.New()
    ///         InitializeComponent()
    ///         EncryptedLicenseProvider.SetParameters(LICENSE_PARAMETERS)
    ///         Dim slicense as License
    ///         If Not LicenseManager.IsValid(GetType(MyControl), Me, slicense) Then
    ///             If LicenseManager.CurrentContext.UsageMode = LicenseUsageMode.Runtime Then
    ///                 MessageBox.Show("This application was created using an unlicensed version of MyControl", "Unlicensed Application")
    ///             Else
    ///                 Dim myForm As New LicenseInstallForm
    ///                 myForm.ShowDialog("MyControl", "www.mycompany.com", GetType(MyControl))
    ///             End If
    ///         End If
    ///    End Sub
    /// End Class   
    /// </code>
    /// </example>
    /// <seealso cref="EncryptedLicense"/>
//#if PUBLIC_LICENSE_CLASS  // if true allows class to be visible outside library  
//    public
//#endif
    public class EncryptedLicenseProvider : LicenseProvider
	{

        #region Member Variables

        private static bool _useMachineKeyStore = false;
        private static RSAParameters _rsaParameters;
        private static byte[] _designSignature;
        private static byte[] _runtimeSignature;

        private static byte[] _desKey = new byte []  { 0x92, 0x15, 0x38, 0xA1, 0x12, 0xED, 0xB3, 0xC2 };
        private static byte[] _desIV = new byte []  { 0xAD, 0x3F, 0xC6, 0x11, 0x47, 0x90, 0xDD, 0xA1 };
       
        // the license parameters for the Licensing System itself
        //
        private const string _systemParameters = @"<LicenseParameters><RSAKeyValue><Modulus>rmIq3rREqKWFkNoX070EtJRGbN6dg4L4ZjF2gVty8xtHtP+m3XEvAi+g0B68bdLNjZYBfk4T2Ku1QAXocJSUP28zGcthe93uFrYKZlSCi6WfjJnMe3BuHWm19OW9tsI4vWV/Utjzft3MKYtVbl99z+EgNFVe6QjIPCiftoU3gDc=</Modulus><Exponent>AQAB</Exponent></RSAKeyValue><DesignSignature>ePFsXJV6rEcW0OyZRhCVT48SUaN0pBqOSADaIOxklLgoF8DhSJ8MRZydnEc2YMKF0zS/U1pdXJghdRhZY5hPNBwpmfrOXSRLsPJ/fQ58/EdyEiRR5MmGeOKUnZLuPeYakrLtVd2AwSKFiGFGxZ2uTwttftI+bmBXY+WenXZHg+Y=</DesignSignature><RuntimeSignature>bm+6Z4FzAp4cZc7l5eljGyhsVU0wLvBjx4VOkt7Td86O/0VMEaYddhAhTAA4jZTNm0oirWorJ4xfrfZAI6os+hs+mHYJ1uqQlNprGAB0hQob4GyTmfig9AThRltLIrooFMm3UQ14jO6badbKhJk0Gykgv9wZxNe1OPlFS3rck0A=</RuntimeSignature><KeyStrength>15</KeyStrength></LicenseParameters>";

        // The length of the key to to use for verification
        //
        private static int _keyStrength = 7;

        // Should a checksum of the product info be used
        //
        private static bool _checksumProductInfo = false;

        // the license for the Licensing System
        //
        private static EncryptedLicense _systemLicense;

        #endregion

        #region Public Interface

        /// <summary>
        /// Set the parameters used to validate licenses created by this provider.
        /// </summary>
        /// <remarks>
        /// This must be called by the client software prior to obtaining licenses using the EncryptedLicenseProvider.
        /// The parameters are generated using the Infralution License Key Generator and pasted into the calling client code.
        /// </remarks>
        /// <param name="licenseParameters">An XML string containing parameters used to validate licenses</param>
        public static void SetParameters(string licenseParameters)
        {
            // set the default key strength
            //
            _keyStrength = 7;
            _checksumProductInfo = false;

            // parse the validation parameters
            // 
            XmlReader reader = new XmlTextReader(licenseParameters, XmlNodeType.Element, null);
            while (reader.Read())
            {
                if (reader.IsStartElement())
                {
                    if (reader.LocalName == "RSAKeyValue")
                    {
                        reader.ReadStartElement("RSAKeyValue");
                        string modulus = Strip(reader.ReadElementString("Modulus"), "\t\r\n ");
                        _rsaParameters.Modulus = Convert.FromBase64String(modulus);
                        string exponent = Strip(reader.ReadElementString("Exponent"), "\t\r\n ");
                        _rsaParameters.Exponent = Convert.FromBase64String(exponent);
                        reader.ReadEndElement();
                    }
                    if (reader.LocalName == "DesignSignature")
                    {
                        string key = reader.ReadElementString();
                        _designSignature = Convert.FromBase64String(key);
                    }
                    if (reader.LocalName == "RuntimeSignature")
                    {
                        string key = reader.ReadElementString();
                        _runtimeSignature = Convert.FromBase64String(key);
                    }
                    if (reader.LocalName == "KeyStrength")
                    {
                        string key = reader.ReadElementString();
                        _keyStrength = int.Parse(key, CultureInfo.InvariantCulture);
                    }
                    if (reader.LocalName == "ChecksumProductInfo")
                    {
                        string key = reader.ReadElementString();
                        _checksumProductInfo = bool.Parse(key);
                    }
                }
            }
            reader.Close();
        }

        /// <summary>
        /// Determines whether RSA keys used to decrypt licenses are stored on a user or machine level
        /// </summary>
        /// <remarks>
        /// Setting this value to true may be useful when impersonating or running under an account 
        /// whose user profile is not loaded.  ILS will by default use the MachineKeyStore when there
        /// is no interactive user (ie services and ASP.NET) otherwise it will use the UserKeyStore.
        /// </remarks>
        /// <seealso cref="RSACryptoServiceProvider.UseMachineKeyStore"/>
        public static bool UseMachineKeyStore
        {
            get { return _useMachineKeyStore; }
            set { _useMachineKeyStore = value; }
        }

        /// <summary>
        /// Generate the XML license parameter string that is used to validate licenses generated using the 
        /// given password
        /// </summary>
        /// <param name="password">The password used to encrypted the license data</param>
        /// <param name="keyStrength">
        /// The keyStrength defines the size (in bytes) of the key verified by public key encryption.  The longer the key
        /// the harder it is to break the licensing scheme by brute force.   Note that increasing the key strength
        /// increases the length of the generated keys.  A KeyStrength of 7 will generate keys that are 32 characters
        /// long.  A KeyStrength of 8 to 15 will generate keys that are 48 characters long
        /// </param>
        /// <param name="checksumProductInfo">
        /// Is a checksum of the <see cref="EncryptedLicense.ProductInfo"/> included in the key.  The checksum is used to validate
        /// that the contents of the <see cref="EncryptedLicense.ProductInfo"/> are valid.  This is really only required if the length of
        /// the <see cref="EncryptedLicense.ProductInfo"/> is 7 or more characters long.  For <see cref="EncryptedLicense.ProductInfo"/> of less 
        /// than 7 characters the ProductInfo is validated by the encryption algorithm. 
        /// </param>
        /// <returns>An XML string which is used to initialise the EncryptedLicenseProvider</returns>
        public string GenerateLicenseParameters(string password, int keyStrength, bool checksumProductInfo)
        {
            if (keyStrength < 7) throw new ArgumentOutOfRangeException("keyStrength", "KeyStrength must be 7 or greater");
            if (password == null) throw new ArgumentNullException("password");

            CspParameters cspParams = new CspParameters();
            
            // if we are running in a server or ASP then ensure that we use the machine CSP
            // store to avoid problems.
            //
            if (!Environment.UserInteractive || UseMachineKeyStore)
            {
                cspParams.Flags = CspProviderFlags.UseMachineKeyStore;
            }
            RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(1024, cspParams);        
            string rsaParam = rsa.ToXmlString(false);

            byte[] designPassword = PadPassword(GetPasswordData(password, keyStrength)); 
            byte[] designSignature = rsa.SignData(designPassword, new SHA1CryptoServiceProvider());

            // encrypt the password using itself to produce the runtime password 
            //
            byte[] encryptionKey = new byte[ArraySize(8)];
            Array.Copy(designPassword, 0, encryptionKey, 0, 7);

            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = _desKey; 
            des.IV = encryptionKey;
            byte[] encKey = des.CreateEncryptor().TransformFinalBlock(designPassword, 0, designPassword.Length);

            byte[] runtimePassword = new byte[ArraySize(keyStrength)];
            Array.Copy(encKey, 0, runtimePassword, 0, keyStrength);
            runtimePassword = PadPassword(runtimePassword);

            // sign the runtime key
            //
            byte[] runtimeSignature = rsa.SignData(runtimePassword, new SHA1CryptoServiceProvider());

            // write the license parameters out to an XML string
            //
            MemoryStream stream = new MemoryStream();
            XmlTextWriter writer = new XmlTextWriter(stream, Encoding.ASCII);
            writer.WriteStartElement("LicenseParameters");  
            writer.WriteRaw(rsaParam);
            writer.WriteElementString("DesignSignature", Convert.ToBase64String(designSignature));
            writer.WriteElementString("RuntimeSignature", Convert.ToBase64String(runtimeSignature));
            writer.WriteElementString("KeyStrength", keyStrength.ToString(CultureInfo.InvariantCulture));
            if (checksumProductInfo)
            {
                writer.WriteElementString("ChecksumProductInfo", checksumProductInfo.ToString(CultureInfo.InvariantCulture));
            }
            writer.WriteEndElement();
            writer.Close();
            string xml = ASCIIEncoding.ASCII.GetString(stream.ToArray());
            stream.Close();
            return xml;
        }

        /// <summary>
        /// Generate a new encrypted license using the given password
        /// </summary>
        /// <param name="keyStrength">The strength of the key to generate</param>
        /// <param name="password">The password used to encrypted the license data</param>
        /// <param name="productInfo">User defined data about the product being licensed</param>
        /// <param name="checksumProductInfo">
        /// Is a checksum of the <see cref="EncryptedLicense.ProductInfo"/> included in the key.  The checksum is used to validate
        /// that the contents of the <see cref="EncryptedLicense.ProductInfo"/> are valid.  This is really only required if the length of
        /// the <see cref="EncryptedLicense.ProductInfo"/> is 7 or more characters long.  For <see cref="EncryptedLicense.ProductInfo"/> of less 
        /// than 7 characters the ProductInfo is validated by the encryption algorithm. 
        /// </param>
        /// <param name="serialNo">The unique license serial number</param>
        /// <returns>A hex encoded encrypted license key</returns>
        /// <remarks>
        /// If there is no installed license for the Infralution Licensing System then the only 
        /// allowed password is "TEST" and the only allowed serial numbers are 1 or 0.  To use the
        /// licensed version of this method ensure that the file Infralution.Licensing.EncryptedLicenseProvider.lic
        /// exists in the same directory as the Infralution.Licensing.dll and contains a valid
        /// license key for the Licensing System.
        /// </remarks>
        public virtual string GenerateKey(int keyStrength, string password, string productInfo, bool checksumProductInfo, Int32 serialNo)
        {
            if (password == null) throw new ArgumentNullException("password");
            if (productInfo == null) productInfo = "";

            byte[] passwordData = GetPasswordData(password, keyStrength); 
            byte[] productData = ASCIIEncoding.UTF8.GetBytes(productInfo);
 
#if CHECK_PUBLIC_KEY

            const string passwordErrorMsg = "The only allowable password in evaluation mode is 'TEST'";
            const string serialNoErrorMsg = "The only allowable serial numbers in evaluation mode are '0' or '1'";

            // if the Licensing System is not licensed then we need to check the password and client ID
            //
            if (SystemLicense == null)
            {
                if (password != "TEST")
                    throw new LicenseException(typeof(EncryptedLicenseProvider), this, passwordErrorMsg);
                if (serialNo < 0 || serialNo > 1)
                    throw new LicenseException(typeof(EncryptedLicenseProvider), this, serialNoErrorMsg);
            }
#endif

            return GenerateKey(keyStrength, passwordData, productData, checksumProductInfo, serialNo);
        }

        
        /// <summary>
        /// Install a license key for the given component or control type.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This method is used to install licenses for components and controls.  The <see cref="InstallLicense(string, string)"/>
        /// method is typically better for installing application licenses because it provides more control over the 
        /// license key file name.  This license key file used by this method is the full type name followed by a ".lic" suffix. 
        /// </para>
        /// <para>
        /// This method verifies that the key is valid and if it is creates the license file and stores the license key. 
        /// The generic Infralution.Licensing.LicenseInstallForm uses this method to install licenses for types.  
        /// Client components may implement their own registration forms that call this method.
        /// </para>
        /// <para>
        /// The <see cref="SetParameters"/> method MUST be called before using this method.  
        /// </para>
        /// </remarks>
        /// <param name="type">The type to install the license for</param>
        /// <param name="licenseKey">The license key to install</param>
        /// <returns>A license if succesful or null/nothing if not</returns>
        public virtual EncryptedLicense InstallLicense(Type type, string licenseKey)
        {
            // validate the license key
            //
            EncryptedLicense license = LoadLicense(LicenseManager.CurrentContext, type, licenseKey);
            if (license != null)
            {
                string licenseFile = GetLicenseFilePath(LicenseManager.CurrentContext, type);             
                WriteKeyToFile(licenseFile, licenseKey);
            }
            return license;
        }

        /// <summary>
        /// Install a license key for an application in the given file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This method is used to install licenses for applications.  Use the <see cref="InstallLicense(Type, string)"/>
        /// method to install licenses for components or controls.  If a full path is not specified for licenseFile then
        /// the file will be created relative to the entry executable directory.
        /// </para>
        /// <para>
        /// This method verifies that the key is valid and if it is creates a license file with the given name
        /// and stores the license key.  This method is used by client applications to allow customers to install
        /// a license for an application.  The generic Infralution.Licensing.LicenseInstallForm uses this method to 
        /// install licenses for applications.  Client applications may implement their own registration forms 
        /// that call this method.  
        /// </para>
        /// <para>
        /// The <see cref="SetParameters"/> method MUST be called before using this method.  
        /// </para>
        /// </remarks>
        /// <param name="licenseFile">The name of the file to install the license key in</param>
        /// <param name="licenseKey">The license key to install</param>
        /// <returns>A license if succesful or null/nothing if not</returns>
        public virtual EncryptedLicense InstallLicense(string licenseFile, string licenseKey)
        {
            // validate the license key
            //
            EncryptedLicense license = LoadLicense(LicenseManager.CurrentContext, null, licenseKey);
            if (license != null)
            {
                string baseDir = GetLicenseDirectory(LicenseManager.CurrentContext, null);
                string path = System.IO.Path.Combine(baseDir, licenseFile);
                string dir = Path.GetDirectoryName(path);
                if (!Directory.Exists(dir))
                {
                    Directory.CreateDirectory(dir);
                }
                WriteKeyToFile(path, licenseKey);
            }
            return license;
        }

        /// <summary>
        /// Install a license key for an application in the given file.
        /// </summary>
        /// <remarks>
        /// <para>
        /// This method is used to install licenses for applications.  Use the <see cref="InstallLicense(Type, string)"/>
        /// method to install licenses for components or controls.  If a full path is not specified for licenseFile then
        /// the file will be created relative to the entry executable directory.
        /// </para>
        /// <para>
        /// This method verifies that the key is valid and if it is creates a license file with the given name
        /// and stores the license key.  This method is used by client applications to allow customers to install
        /// a license for an application.  The generic Infralution.Licensing.LicenseInstallForm uses this method to 
        /// install licenses for applications.  Client applications may implement their own registration forms 
        /// that call this method.  
        /// </para>
        /// <para>
        /// This method is an alternative to calling <see cref="SetParameters"/> followed by 
        /// <see cref="InstallLicense(string, string)"/>.
        /// </para>
        /// </remarks>
        /// <param name="licenseParameters">An XML string containing parameters used to validate the license key</param>
        /// <param name="licenseFile">The name of the file to install the license key in</param>
        /// <param name="licenseKey">The license key to install</param>
        /// <returns>A license if succesful or null/nothing if not</returns>
        public virtual EncryptedLicense InstallLicense(string licenseParameters, 
                                                       string licenseFile, 
                                                       string licenseKey)
        {
            SetParameters(licenseParameters);
            return InstallLicense(licenseFile, licenseKey);
        }

        /// <summary>
        /// Validate that the given license key is valid for the current licensing parameters
        /// </summary>
        /// <param name="licenseKey">The license key to validate</param>
        /// <returns>The encrypted license if the key is valid otherwise null</returns>
        /// <remarks>
        /// <para>
        /// This method provides a mechanism to validate that a given license key is valid
        /// prior to attempting to install it.   This can be useful if you want to check
        /// the <see cref="EncryptedLicense.ProductInfo"/> before installing the license.
        /// </para>
        /// <para>
        /// The <see cref="SetParameters"/> method MUST be called before using this method.  
        /// </para>
        /// </remarks>
        /// <seealso cref="ValidateLicenseKey(string, string)"/> 
        public virtual EncryptedLicense ValidateLicenseKey(string licenseKey)
        {
            return LoadLicense(LicenseManager.CurrentContext, null, licenseKey);
        }

        /// <summary>
        /// Validate that the given license key is valid for the given licensing parameters
        /// </summary>
        /// <param name="licenseParameters">An XML string containing parameters used to validate the license key</param>
        /// <param name="licenseKey">The license key to validate</param>
        /// <returns>The encrypted license if the key is valid otherwise null</returns>
        /// <remarks>
        /// <para>
        /// This method provides a mechanism to validate that a given license key is valid
        /// prior to attempting to install it.   This can be useful if you want to check
        /// the <see cref="EncryptedLicense.ProductInfo"/> before installing the license.  
        /// </para>
        /// <para>
        /// This method is an alternative to calling <see cref="SetParameters"/> followed by 
        /// <see cref="ValidateLicenseKey(string)"/>.
        /// </para>
        /// </remarks>
        public virtual EncryptedLicense ValidateLicenseKey(string licenseParameters,
                                                           string licenseKey)
        {
            SetParameters(licenseParameters);
            return LoadLicense(LicenseManager.CurrentContext, null, licenseKey);
        }

        /// <summary>
        /// Get a license (if installed) from the given license file.
        /// </summary>
        /// <param name="licenseFile">The name of the license file containing the license key</param>
        /// <returns>The installed license key if any</returns>
        /// <remarks>
        /// <para>
        /// This method is used to read licenses for applications.  Components and controls should use the 
        /// <see cref="LicenseManager"/> methods to load and validate licenses.  If a full path is not specified 
        /// for licenseFile then the file loaded will be relative to the directory containing the application 
        /// executable (for Window Forms applications) or aspx files (for ASP.NET applications).
        /// </para>
        /// <para>
        /// The <see cref="SetParameters"/> method MUST be called before using this method.  
        /// </para>
        /// </remarks>
        public virtual EncryptedLicense GetLicense(string licenseFile)
        {
            string dir = GetLicenseDirectory(LicenseManager.CurrentContext, null);
            string path = System.IO.Path.Combine(dir, licenseFile);             
            string licenseKey = ReadKeyFromFile(path);
            EncryptedLicense license = null;
            if (licenseKey != null)
            {
                license = LoadLicense(LicenseManager.CurrentContext, null, licenseKey);
            }
            return license;
        }
 
        /// <summary>
        /// Get a license (if installed) from the given license file.
        /// </summary>
        /// <param name="licenseParameters">An XML string containing parameters used to validate the license key</param>
        /// <param name="licenseFile">The name of the license file containing the license key</param>
        /// <returns>The installed license key if any</returns>
        /// <remarks>
        /// <para>
        /// This method is used to read licenses for applications.  Components and controls should use the 
        /// <see cref="LicenseManager"/> methods to read and validate licenses.  If a full path is not specified 
        /// for licenseFile then the file loaded will be relative to the directory containing the application 
        /// executable (for Window Forms applications) or aspx files (for ASP.NET applications).
        /// </para>
        /// <para>
        /// This method is an alternative to calling <see cref="SetParameters"/> followed by 
        /// <see cref="GetLicense(string)"/>.
        /// </para>
        /// </remarks>
        public virtual EncryptedLicense GetLicense(string licenseParameters,
                                                   string licenseFile)
        {
            SetParameters(licenseParameters);
            return GetLicense(licenseFile);
        }
                                        
        /// <summary>
        /// Get a license (if installed) for the given component/control type 
        /// </summary>
        /// <param name="context">The context (design or runtime)</param>
        /// <param name="type">The type to get the license for</param>
        /// <param name="instance">The object the license is for</param>
        /// <param name="allowExceptions">If true a <see cref="LicenseException"/> is thrown if a valid license cannot be loaded</param>
        /// <returns>An encrypted license</returns>
        /// <remarks>
        /// <para>
        /// This method is used to get licenses for components and controls.  Applications should generally
        /// use the <see cref="GetLicense(string, string)"/> method as it provides more control over the license file
        /// that keys are stored in.  This method is not typically called directly by application code.  
        /// Instead the component or control uses the <see cref="LicenseManager.IsValid(Type)"/> or
        /// <see cref="LicenseManager.Validate(Type)"/> methods which find the <see cref="LicenseProvider"/> for the type
        /// and call this method.
        /// </para>
        /// <para>
        /// You must call <see cref="SetParameters"/> before calling this method either directly or
        /// indirectly by via a call to <see cref="LicenseManager.IsValid(Type)"/>
        /// </para>
        /// </remarks>
        public override License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions)
        {
            string licenseKey = GetLicenseKey(context, type);
            License license = LoadLicense(context, type, licenseKey);
            if (license == null && allowExceptions)
            {
                if (instance == null)
                    throw new LicenseException(type);
                else
                    throw new LicenseException(type, instance);
            }
            return license;
        }

        /// <summary>
        /// Return the license for the given type from a given DLL assembly resources
        /// </summary>
        /// <param name="context">The license context to validate the license in</param>
        /// <param name="assembly">The assembly containing the license</param>
        /// <param name="type">The type to get the license for</param>
        /// <returns>The license key if any</returns>
        /// <remarks>
        /// This method can be used to check the given DLL assembly for a license.  By default the .NET licensing
        /// framework only checks the entry assembly (ie typically executables) for licenses.  This means
        /// that if a licensed control is wrapped in another control, the customer of the wrapped control will
        /// still required a design time license key for the original control.  This is generally the behaviour
        /// that control authors would like.  If however you want to provide a license that enables a customer
        /// to create new component/controls using your control/component then you can achieve this by using 
        /// this method to check for a license in the CallingAssembly that created the control/component.
        /// </remarks>
        public virtual EncryptedLicense GetLicense(LicenseContext context, Assembly assembly, Type type)
        {
            if (assembly == null) return null;
            EncryptedLicense license = null;
            string licenseKey = GetSavedLicenseKey(assembly, type);
            if (licenseKey != null)
            {
                license = LoadLicense(context, null, licenseKey);
            }
            return license;
        }

        /// <summary>
        /// Return the license for the Infralution Licensing System itself
        /// </summary>
        /// <returns>The license data if successful or null if not</returns>
        internal static EncryptedLicense SystemLicense
        {
            get
            {
                if (_systemLicense == null)
                {
                    SetParameters(_systemParameters);
                    EncryptedLicenseProvider provider = new EncryptedLicenseProvider();
                    _systemLicense = provider.GetLicense(LicenseManager.CurrentContext, typeof(EncryptedLicenseProvider), null, false) as EncryptedLicense;
                }
                return _systemLicense;
            }
        }

        #endregion

        #region Local Methods

        /// <summary>
        /// Return the array size to use when declaring an array of the given length.
        /// </summary>
        /// <param name="length">The length of the array you are declaring</param>
        /// <returns>The size to declare the array</returns>
        /// <remarks>
        /// This is used to account for the difference between declaring VB and C# arrays and
        /// permit automatic conversion of the code to VB
        /// </remarks>
        private static int ArraySize(int length)
        {
            return length;
        }

        /// <summary>
        /// Return the given input string stripped of the given characters
        /// </summary>
        /// <param name="value">The string to strip</param>
        /// <param name="characters">The characters to strip from the string</param>
        /// <returns>The input string with the given characters removed</returns>
        private static string Strip(string value, string characters)
        {
            if (value == null) return null;
            StringBuilder sb = new StringBuilder();
            foreach (char ch in value)
            {
                if (characters.IndexOf(ch, 0) < 0)
                {
                    sb.Append(ch);
                }
            }
            return sb.ToString();       
        }

        /// <summary>
        /// Converts a byte array into a hexadecimal representation.
        /// </summary>
        /// <param name="data">The byte data to convert</param>
        /// <returns>Hexadecimal representation of the data</returns>
        private static string ToHex(byte[] data)
        {
            StringBuilder sb = new StringBuilder();
            for (int i=0; i < data.Length; i++)
            {
                if (i > 0 && i % 2 == 0)
                {
                    sb.Append("-");
                }
                sb.Append(data[i].ToString("X2", CultureInfo.InvariantCulture));
            }
            return sb.ToString();
        }

        /// <summary>
        /// Converts a hexadecimal string into a byte array.
        /// </summary>
        /// <param name="hex">The hexadecimal string to convert</param>
        /// <returns>The converted byte data</returns>
        private static byte[] FromHex(string hex)
        {
            string strippedHex = Strip(hex, "\t\r\n -");
            if (strippedHex == null || strippedHex.Length % 2 != 0) 
                throw new FormatException("Invalid hexadecimal string");
            byte[] result = new byte[ArraySize(strippedHex.Length / 2)];
            for (int i=0, j = 0; i < strippedHex.Length; i += 2, j++)
            {
                string s = strippedHex.Substring(i, 2);
                result[j] = byte.Parse(s, NumberStyles.HexNumber, CultureInfo.InvariantCulture);                 
            }
            return result;
        }

        /// <summary>
        /// Are the contents of the two byte arrays equal
        /// </summary>
        /// <param name="a1">The first array</param>
        /// <param name="a2">The second array </param>
        /// <returns>True if the contents of the arrays is equal</returns>
        private static bool ArrayEqual(byte[] a1, byte[] a2)
        {
            if (a1 == a2) return true;
            if ((a1 == null) || (a2 == null)) return false;
            if (a1.Length != a2.Length) return false;
            for (int i=0; i < a1.Length; i++)
            {
                if (a1[i] != a2[i]) return false;
            }
            return true;
        }

        /// <summary>
        /// Generate the password data used to verify and decrypt the license
        /// </summary>
        /// <param name="password">The password used to generate the key</param>
        /// <param name="keyStrength">The strength of the key to create</param>
        /// <returns>The password data used to verify and decrypt the license</returns> 
        private static byte[] GetPasswordData(string password, int keyStrength)
        {
            byte[] key = new byte []  { 0xF2, 0xA1, 0x03, 0x9D, 0x63, 0x87, 0x35, 0x5E };
            byte[] iv = new byte []  { 0xAB, 0xB8, 0x94, 0x7E, 0x1D, 0xE5, 0xD1, 0x33 };

            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = key;
            des.IV = iv;

            int padLength = Math.Max(keyStrength, 8); 
            if (password.Length < padLength) 
                password = password.PadRight(padLength, '*');
            byte[] data = ASCIIEncoding.ASCII.GetBytes(password);
            byte[] encPassword = des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);
            byte[] result = new byte[ArraySize(keyStrength)];
            Array.Copy(encPassword, 0, result, 0, keyStrength);
            return result;
        }

        /// <summary>
        /// Pad the given password if required.
        /// </summary>
        /// <param name="passwordData">The password data to pad</param>
        /// <returns>The padded password data</returns> 
        /// <remarks>
        /// This function is required for backward compatibility with 7 byte passwords which were
        /// padded before being signed
        /// </remarks>
        private static byte[] PadPassword(byte[] passwordData)
        {
            if (passwordData.Length == 7)
            {
                byte[] result = new byte[ArraySize(8)];
                Array.Copy(passwordData, 0, result, 0, passwordData.Length);
                return result;
            }
            return passwordData;
        }

        /// <summary>
        /// Create a checksum for the given block of data
        /// </summary>
        /// <param name="data">The block of data to create a checksum for</param>
        /// <returns>An integer checksum</returns>
        private UInt16 Checksum(byte[] data)
        {
            int hash = 5381;
            int c;
            int i = 0;

            while (i < data.Length)
            {
                c = data[i];

                hash = ((hash << 5) + hash) ^ c;
                i++;
            }
            hash = hash % UInt16.MaxValue;
            return (UInt16)hash;
        }

        /// <summary>
        /// Generate a new encrypted license 
        /// </summary>
        /// <param name="keyStrength">The strength of the key to generate</param>
        /// <param name="passwordData">The password used to encrypted the license data</param>
        /// <param name="productData">User defined data about the product being licensed</param>
        /// <param name="checksumProductInfo">
        /// Is a checksum of the <see cref="EncryptedLicense.ProductInfo"/> included in the key.  The checksum is used to validate
        /// that the contents of the <see cref="EncryptedLicense.ProductInfo"/> are valid.  This is really only required if the length of
        /// the <see cref="EncryptedLicense.ProductInfo"/> is 7 or more characters long.  For <see cref="EncryptedLicense.ProductInfo"/> of less 
        /// than 7 characters the ProductInfo is validated by the encryption algorithm. 
        /// </param>
        /// <param name="serialNo">The unique license serial number</param>
        /// <returns>A hex encoded encrypted license key</returns>
        /// <remarks>
        /// If there is no installed license for the Infralution Licensing System then the only 
        /// allowed password is "TEST" and the only allowed serial numbers are 1 or 0.  To use the
        /// licensed version of this method ensure that the file Infralution.Licensing.EncryptedLicenseProvider.lic
        /// exists in the same directory as the Infralution.Licensing.dll and contains a valid
        /// license key for the Licensing System.
        /// </remarks>
        private string GenerateKey(int keyStrength, byte[] passwordData, byte[] productData, bool checksumProductInfo, Int32 serialNo)
        {
            if (keyStrength < 7) throw new ArgumentOutOfRangeException("keyStrength", "KeyStrength must be 7 or greater");
            if (serialNo < 0 || serialNo > UInt16.MaxValue) throw new ArgumentOutOfRangeException("serialNo", "serialNo must be non-negative and less than 65536");
            UInt16 userialNo = (UInt16)serialNo;


            // Public Key token for the Infralution signed assemblies
            //            
            byte[] requiredToken = { 0x3E, 0x7E, 0x8E, 0x37, 0x44, 0xA5, 0xC1, 0x3F };
            byte[] publicKeyToken = Assembly.GetExecutingAssembly().GetName().GetPublicKeyToken();
            byte[] testKey = { 0x3E, 0x7E, 0x8E, 0x37, 0x44, 0xA5, 0xC1, 0x3F };

#if CHECK_PUBLIC_KEY

            // Validate this assembly - if it isn't signed with the correct public key
            // then copy rubbish into the key.  This is to make it just a little more
            // difficult for the casual hacker.
            //
            if (!ArrayEqual(publicKeyToken, requiredToken))
            {
                _desKey.CopyTo(passwordData, 0);
            }
#endif

            int checksumLength = (checksumProductInfo) ? 2 : 0;
            byte[] clientData = BitConverter.GetBytes(userialNo);
            byte[] payload = new byte[ArraySize(productData.Length + clientData.Length + checksumLength)];

            clientData.CopyTo(payload, 0);
            productData.CopyTo(payload, 2);

            // calculate the product data checksum and add to the payload
            //
            if (checksumProductInfo)
            {
                UInt16 checksum = Checksum(productData);
                byte[] checksumData = BitConverter.GetBytes(checksum);
                checksumData.CopyTo(payload, payload.Length - checksumLength);
            }

            // Encrypt the payload. The key used for encrypting the payload is just the first 7 bytes of the password data
            //
            byte[] encryptionKey = new byte[ArraySize(8)];
            Array.Copy(passwordData, 0, encryptionKey, 0, 7);
            DESCryptoServiceProvider des = new DESCryptoServiceProvider();
            des.Key = _desKey;
            des.IV = encryptionKey;
            byte[] encPayload = des.CreateEncryptor().TransformFinalBlock(payload, 0, payload.Length);

            // Combine the password data and encrypted payload 
            //
            byte[] data = new byte[ArraySize(passwordData.Length + encPayload.Length)];

            // For key strengths greater than 8 we swap the order of the payload and password data
            // This ensures that the first 8 bytes do not always end up hex encoded the same
            //
            if (keyStrength < 8)
            {
                passwordData.CopyTo(data, 0);
                encPayload.CopyTo(data, passwordData.Length);
            }
            else
            {
                encPayload.CopyTo(data, 0);
                passwordData.CopyTo(data, encPayload.Length);
            }

            // encrypt again to obscure the password - this time using preset encryption key
            //
            des.IV = _desIV;
            byte[] encData = des.CreateEncryptor().TransformFinalBlock(data, 0, data.Length);

            return ToHex(encData);
        }

        /// <summary>
        /// Extract the license for the given type from the given licenseKey
        /// </summary>
        /// <param name="context">The current licensing context</param>
        /// <param name="type">The type to be licensed</param>
        /// <param name="licenseKey">The encrypted hexadecimal license key</param>
        /// <returns>A license for the given type or NULL if the licenseKey was invalid</returns>
        protected virtual EncryptedLicense LoadLicense(LicenseContext context, Type type, string licenseKey)
        {
            // check that validation parameters have been set by the client
            //
            if (_designSignature == null || _runtimeSignature == null) 
                throw new InvalidOperationException("EncryptedLicenseProvider.SetParameters must be called prior to using the EncryptedLicenseProvider");
            if (licenseKey == null) return null;

            try
            {
                byte[] encData = FromHex(licenseKey);

                DESCryptoServiceProvider des = new DESCryptoServiceProvider();
                des.Key = _desKey; 
                des.IV = _desIV;
            
                byte[] data = des.CreateDecryptor().TransformFinalBlock(encData, 0, encData.Length);
       
                // extract the password data and encrypted product data 
                //
                byte[] passwordData = new byte[ArraySize(_keyStrength)];
                byte[] encPayload = new byte[ArraySize(data.Length - _keyStrength)];

                // for key strengths greater than 8 the order of payload and key is swapped
                //
                if (_keyStrength < 8)
                {
                    Array.Copy(data, 0, passwordData, 0, _keyStrength);
                    Array.Copy(data, _keyStrength, encPayload, 0, encPayload.Length);
                }
                else
                {
                    Array.Copy(data, 0, encPayload, 0, encPayload.Length);
                    Array.Copy(data, encPayload.Length, passwordData, 0, _keyStrength);
                }

                // the key used to encrypt payload is just the first 7 bytes of the password data
                //
                byte[] encryptionKey = new byte[ArraySize(8)];
                Array.Copy(passwordData, 0, encryptionKey, 0, 7);

                // validate that the password matches what the client is expecting
                //
                CspParameters cspParams = new CspParameters();

                // if we are running in a server or ASP then ensure that we use the machine CSP
                // store to avoid problems.
                //
                if (!Environment.UserInteractive || UseMachineKeyStore)
                {
                    cspParams.Flags = CspProviderFlags.UseMachineKeyStore;
                }
                RSACryptoServiceProvider rsa = new RSACryptoServiceProvider(cspParams);
                rsa.ImportParameters(_rsaParameters);

                byte[] paddedPasswordData = PadPassword(passwordData);
                if (context.UsageMode == LicenseUsageMode.Designtime)
                {

                    // if design time license requested then the license MUST be a design license
                    //
                    if (!rsa.VerifyData(paddedPasswordData, new SHA1CryptoServiceProvider(), _designSignature)) return null;
                }
                else
                {
                    // if runtime license requested then first check if the license is a runtime license
                    // also allow design licenses to work at runtime
                    //
                    if (!rsa.VerifyData(paddedPasswordData, new SHA1CryptoServiceProvider(), _runtimeSignature))
                    {
                        if (!rsa.VerifyData(paddedPasswordData, new SHA1CryptoServiceProvider(), _designSignature)) return null;
                    }
                }

                // decrypt the payload using the encryption key
                //
                des.IV = encryptionKey;
                byte[] payload = des.CreateDecryptor().TransformFinalBlock(encPayload, 0, encPayload.Length);

                int checksumLength = (_checksumProductInfo) ? 2 : 0;
                byte[] productData = new byte[ArraySize(payload.Length - 2 - checksumLength)];
                Array.Copy(payload, 2, productData, 0, productData.Length);

                UInt16 serialNo = BitConverter.ToUInt16(payload, 0);
                string product = System.Text.ASCIIEncoding.UTF8.GetString(productData); 
        
                // validate the product data checksum
                //
                if (_checksumProductInfo)
                {
                    UInt16 requiredChecksum = BitConverter.ToUInt16(payload, payload.Length - checksumLength);
                    UInt16 actualChecksum = Checksum(productData);
                    if (requiredChecksum != actualChecksum)
                        return null;
                }
 
                // if in design time then create a runtime license and save it
                //
                if (context.UsageMode == LicenseUsageMode.Designtime && type != null)
                {

                    // create the runtime password by encrypting the design password
                    //
                    byte[] encPassword = des.CreateEncryptor().TransformFinalBlock(paddedPasswordData, 0, paddedPasswordData.Length);
                    byte[] runtimePasswordData = new byte[ArraySize(_keyStrength)];
                    Array.Copy(encPassword, 0, runtimePasswordData, 0, _keyStrength);

                    string runtimeLicenseKey = GenerateKey(_keyStrength, runtimePasswordData, productData,_checksumProductInfo, serialNo);

                    // save the runtime key into the context
                    //
                    context.SetSavedLicenseKey(type, runtimeLicenseKey);            
                }
                return new EncryptedLicense(licenseKey, serialNo, product);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Read a license key from the given file
        /// </summary>
        /// <param name="licenseFile">The path to the license file to read the key from</param>
        /// <returns>The license key if any</returns>
        protected virtual string ReadKeyFromFile(string licenseFile)
        {
            string key = null;
            if (File.Exists(licenseFile)) 
            {
                Stream stream = new FileStream(licenseFile, FileMode.Open, FileAccess.Read, FileShare.Read);
                StreamReader reader = new StreamReader(stream);
                key = reader.ReadToEnd();
                reader.Close();
            }
            return key;
        }

        /// <summary>
        /// Write a license key to the given file
        /// </summary>
        /// <param name="licenseFile">The path to the license file to write the key to</param>
        /// <param name="licenseKey">The license key to write</param>
        protected virtual void WriteKeyToFile(string licenseFile, string licenseKey)
        {
            Stream stream = new FileStream(licenseFile, FileMode.Create, FileAccess.Write, FileShare.None);
            StreamWriter writer = new StreamWriter(stream);
            writer.WriteLine(licenseKey);
            writer.Close();
        }

        /// <summary>
        /// Return the license key for the given context and type
        /// </summary>
        /// <remarks>
        /// This can be overridden to change where the license key is stored by the provider.   For
        /// instance a derived class could override this method to store the key in the Registry.
        /// </remarks>
        /// <param name="context">The license context</param>
        /// <param name="type">The type to get the key for</param>
        /// <returns>The license key</returns>
        protected virtual string GetLicenseKey(LicenseContext context, Type type)
        {
            string key = null;
            if (context.UsageMode == LicenseUsageMode.Runtime) 
            {
                try
                {
                    key = context.GetSavedLicenseKey(type, null);
                }
                catch
                {
                    // if something goes wrong retrieving the saved license key then just ignore it
                    // and try reading from file                    
                }
            }

            // if we're in design mode or a suitable license key wasn't found in 
            // the runtime context look for a .LIC file
            //
            if (key == null) 
            {       				
                key = ReadKeyFromFile(GetLicenseFilePath(context, type));
            }
            return key;
        }

        /// <summary>
        /// Return the directory used to store license files
        /// </summary>
        /// <param name="context">The licence context</param>
        /// <param name="type">The type being licensed</param>
        /// <returns>The directory to look for license files</returns>
        protected virtual string GetLicenseDirectory(LicenseContext context, Type type)
        {
            string result = null;

            // try to use the type resolver service if available
            //
            if (context != null && type != null) 
            {
                ITypeResolutionService resolver = (ITypeResolutionService)context.GetService(typeof(ITypeResolutionService));
                if (resolver != null)
                    result = resolver.GetPathOfAssembly(type.Assembly.GetName());
            }
        
            if (result == null)
            {
                if (type == null)
                {
                    result = AppDomain.CurrentDomain.BaseDirectory;
                }
                else
                {
                    Assembly assembly = type.Assembly;

                    // use the code base if possible 
                    //
                    result = assembly.CodeBase;
                    if (result.StartsWith(@"file:///"))
                    {
                        result = result.Replace(@"file:///", "");
                    }
                    else
                    {
                        result = type.Module.FullyQualifiedName;
                    }
                }
            }
            return Path.GetDirectoryName(result);
        }

        /// <summary>
        /// Called by GetLicenseKey to get the file path to obtain the license from (if there is no runtime license saved in the context)
        /// </summary>
        /// <remarks>
        /// This can be overridden to change the file used to store the design time license for the provider.   By default the
        /// the license file is stored in the same directory as the component executable with the name based on the fully
        /// qualified type name eg MyNamespace.MyControl.lic
        /// </remarks>
        /// <seealso cref="GetLicenseKey"/>
        /// <param name="context">The licence context</param>
        /// <param name="type">The type to get the license for</param>
        /// <returns>The path of the license file</returns>
        protected virtual string GetLicenseFilePath(LicenseContext context, Type type)
        {
            string dir = GetLicenseDirectory(context, type);
            return String.Format(@"{0}\{1}.lic", dir, type.FullName);
        }

        /// <summary>
        /// Retrieve the license key for the given type from the given DLL assembly resources
        /// </summary>
        /// <param name="assembly">The assembly containing the license resources</param>
        /// <param name="type">The type to get the license key for</param>
        /// <returns>The license key if any</returns>
        private string GetSavedLicenseKey(Assembly assembly, Type type)
        {
            string key = null;
            string resourceName = assembly.GetName().Name + ".dll.licenses";
            Stream stream = assembly.GetManifestResourceStream(resourceName);
            if (stream != null)
            {
                IFormatter formatter = new BinaryFormatter();
                object[] values = formatter.Deserialize(stream) as object[];
                if (values != null)
                {
                    Hashtable keys = values[1] as Hashtable;
                    if (keys != null)
                    {                    
                        foreach (DictionaryEntry entry in keys)
                        {                           
                            string typeName = entry.Key as String;
                            if (typeName != null)
                            {
                                typeName = typeName.Trim();
                                if (typeName.IndexOf(type.FullName) == 0)
                                {
                                    key = entry.Value as String;
                                    break;
                                }
                            }
                        }
                    }
                } 
                stream.Close();
            }
            return key;
        }
 
        #endregion
	}

}
